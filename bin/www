#!/usr/bin/env node

const http = require("http");
let app = require("../app");

const util = require("util");
const request = require("request");
const requestPromise = util.promisify(request);
const uuidv4 = require("uuid/v4");
const dotenv = require("dotenv");
dotenv.config();

// ---------- get info in .env -------------

let key_var = "TRANSLATOR_TEXT_SUBSCRIPTION_KEY";
if (!process.env[key_var]) {
  throw new Error(
    "Please set/export the following environment variable: " + key_var
  );
}
let subscriptionKey = process.env[key_var];
let endpoint_var = "TRANSLATOR_TEXT_ENDPOINT";
if (!process.env[endpoint_var]) {
  throw new Error(
    "Please set/export the following environment variable: " + endpoint_var
  );
}
let endpoint = process.env[endpoint_var];

// ------- async function due API delay -------------
// @param text to translate & arr of languages to translate to
// wait promise and return it

// async function message(text, arr) {

async function messageFromFrontEnd(text, lgTrans) {
  lgTransCode = lgTrans.substr(0, lgTrans.indexOf(" "));
  console.log(lgTransCode);
  let message = {
    method: "POST",
    baseUrl: endpoint,
    url: "translate",
    qs: {
      "api-version": "3.0",
      to: lgTransCode
    },
    headers: {
      "Ocp-Apim-Subscription-Key": subscriptionKey,
      "Content-type": "application/json",
      "X-ClientTraceId": uuidv4().toString()
    },
    body: [
      {
        text: text
      }
    ],
    json: true
  };

  const response = await requestPromise(message);
  const result = response.body;
  return result;
}

// const foo = async () =>{

// let test = await message("Genau", ["pt", "en", "fr", "it"]);
// console.log(test);

// }

// foo()

app.use((err, req, res, next) => {
  // always log the error
  console.error("ERROR", req.method, req.path, err);

  // only render if the error ocurred before sending the response
  if (!res.headersSent) {
    res.status(500);
  }
});

let server = http.createServer(app);

server.on("error", error => {
  if (error.syscall !== "listen") {
    throw error;
  }

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case "EACCES":
      console.error(`Port ${process.env.PORT} requires elevated privileges`);
      process.exit(1);
      break;
    case "EADDRINUSE":
      console.error(`Port ${process.env.PORT} is already in use`);
      process.exit(1);
      break;
    default:
      throw error;
  }
});

// const socketio = require("socket.io");
// const io = socketio(server);

const io = require("socket.io").listen(server);
const Message = require("../models/Message");
const Room = require("../models/Room");
const User = require("../models/User");

server.listen(process.env.PORT, () => {
  console.log(`Listening on http://localhost:${process.env.PORT}`);
});

const getUsers = () => {
  let clients = io.sockets.clients().connected;
  let sockets = Object.values(clients);
  let users = sockets.map(s => s.user);
  return users;
};

const emitUsers = () => {
  io.emit("users", getUsers());
};

io.on("connection", socket => {
  console.log("Client connected", socket.id);

  socket.on("new_user", user => {
    //console.log("New user:", user);
    socket.user = user;
    emitUsers();
  });

  socket.on("joinRoom", ({ user, room }) => {
    console.log(`User ${user.username} joined: ${room}`);
    socket.join(room);
    //io.sockets.connected[socketID].join(roomName);
  });

  socket.on("joinPrivate", ({ user1, user2 }) => {
    Room.find({ users: { $all: [user1._id, user2._id] } })
      .then(room => {
        if (room.length > 0) {
          socket.emit("room", room);
        } else {
          Room.create({ users: [user1._id, user2._id] }).then(newRoom => {
            console.log(newRoom);
            User.findOneAndUpdate(
              { _id: user1._id },
              { $push: { rooms: newRoom._id } }
            ).then(user => {
              User.findOneAndUpdate(
                { _id: user2._id },
                { $push: { rooms: newRoom._id } }
              ).then(user => {
                io.emit("welcome", `Welcome`);
              });
            });
          });
        }
      })
      .catch(err => console.log(err));
  });

  //   socket.on(
  //     "message",
  //     async ({
  //       message,
  //       userId,
  //       username,
  //       roomId,
  //       socketId,
  //       defaultLanguage
  //     }) => {
  //       const result = await messageFromFrontEnd(message, defaultLanguage);
  //       const newMessage = result[0].translations;
  //       const newAndImprovedMessage = newMessage[0].text;

  //       console.log(newAndImprovedMessage);

  //       Message.create({ text: message, user: userId, username: username })
  //         .then(message => {
  //           io.to(`${socketId}`).emit("message", message);
  //           Room.findOneAndUpdate(
  //             { _id: roomId },
  //             { $push: { messages: message._id } }
  //           ).then(room => {
  //             Message.create({
  //               text: newAndImprovedMessage,
  //               username: username,
  //               user: userId
  //             }).then(msg => {
  //               socket.to(roomId).broadcast.emit("message", msg);
  //               Room.findOneAndUpdate(
  //                 { _id: roomId },
  //                 { $push: { messages: msg._id } }
  //               ).then(room => {});
  //             });
  //           });
  //         })
  //         .catch(err => console.log(err));
  //     }
  //   );

  //   socket.on("disconnect", function() {
  //     emitUsers();
  //     console.log("User disconnected");
  //   });
  // });

  socket.on(
    "message",
    ({ message, userId, username, roomId, socketId, defaultLanguage }) => {
      console.log("USER ID, MESSAGE SENT    ", userId, typeof userId);

      // find the room
      Room.findOne({ _id: roomId })
        .populate("users")
        .then(response => {
          // find the user in the room (second)
          // find his lang
          // console.log("USER response", response.users);
          const [person] = response.users.filter(el => el._id != userId);
          // const array = response.users.map(el => {
          //   newObj = {};
          //   newObj.username = el.username;
          //   newObj.id = el._id;
          //   return newObj;
          // });
          // console.log(array[1].id == userId);
          console.log(person);

          // console.log("userId", userId);
          // const stupidTest = userId.split("").join("");
          // const check =
          //   response.users[0] === userId && response.users[1] === userId;
          // console.log(typeof response.users[0]);
          // const secUser = response.users.find(id => id !== userId);
          // console.log("SEC USER???", secUser);
          // console.log("USERID", userId);
          // console.log("SECUSERID", secUser);
          User.findById(person._id).then(async data => {
            console.log("Looook me in the yes, I said the eyes    ",data.defaultLanguage);
            // console.log("DATA FROM SEC USER", data.defaultLanguage);
            // console.log("DATA FROM SEC USER", data);

            const lang = data.defaultLanguage;
            const result = await messageFromFrontEnd(
              message,
              lang
            );
            const newMessage = result[0].translations;
            const newAndImprovedMessage = newMessage[0].text;

            // console.log("LOOK HERE FLORIANOOOOO", newAndImprovedMessage);

            Message.create({ text: message, user: userId, username: username })
              .then(message => {
                io.to(`${socketId}`).emit("message", message);
                Room.findOneAndUpdate(
                  { _id: roomId },
                  { $push: { messages: message._id } }
                ).then(room => {
                  Message.create({
                    text: newAndImprovedMessage,
                    username: username,
                    user: userId
                  }).then(msg => {
                    socket.to(roomId).broadcast.emit("message", msg);
                    Room.findOneAndUpdate(
                      { _id: roomId },
                      { $push: { messages: msg._id } }
                    ).then(room => {});
                  });
                });
              })
              .catch(err => console.log(err));
          });
        });
    }
  );
  socket.on("disconnect", function() {
    emitUsers();
    console.log("User disconnected");
  });
});

//         });
//       });

// });

// io.sockets.connected[user2.connection.socketId].join(room.name);
// console.log(io.sockets.adapter.rooms[room.name]);
// io.to(room.name).emit("privateRoom", room);

///////////

//   socket.on("message", async ({ message, userId, username, socketId }) => {
//     const result = await messageFromFrontEnd(message);
//     const newMessage = result[0].translations;
//     const newAndImprovedMessage = newMessage[0].text;
//     //  const realThing= `${message}
//     //  ${newAndImprovedMessage}`

//     Message.create({
//       text: message,
//       username: username
//     })
//       .then(msg => {
//         io.to(`${socketId}`).emit("message", msg);
//       })
//       .catch(err => console.log(err));

//     Message.create({
//       text: newAndImprovedMessage,
//       username: username
//     })
//       .then(msg => {
//         socket.broadcast.emit("message", msg);
//       })
//       .catch(err => console.log(err));
//   });

//   socket.on("room", ({ userId }) => {
//     Room.create({ users: [userId], messages: [] })
//       .then(room => {
//         console.log("ROOM CREATED", room);
//         socket.emit("room", room);
//       })
//       .catch(err => console.log(err));
//   });
// });
